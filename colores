#!/usr/bin/bash

version="1.1.1"
appname=$(basename "$0")

declare -A color_layers=(
    ["fore"]="38"
    ["back"]="48"
)

declare -A text_styles=(
    ["bold"]="\e[1m"
    ["italic"]="\e[3m"
    ["underline"]="\e[4m"
    ["flashing"]="\e[5m"
    ["inverted"]="\e[7m"
)

declare -A status_markers=(
    ["success"]="[\e[92m+\e[0m]"
    ["error"]="[\e[91m-\e[0m]"
    ["warning"]="[\e[93m!\e[0m]"
    ["info"]="[\e[32m*\e[0m]"
    ["question"]="[\e[96m?\e[0m]"
    ["on"]="[\e[92mON\e[0m]"
    ["off"]="[\e[91mOFF\e[0m]"
    ["debug"]="[\e[31mDEBUG\e[0m]"
)

lowercase() {
    echo "$1" | tr "[:upper:]" "[:lower:]"
}

get_args() {
    echo -E "${1%% -*}"
}

get_color() {
    local color=($1)
    local color_len=${#color[@]}

    local layer="${color_layers[$2]}"

    if [[ $color_len -eq 3 &&
          "${color[0]}" =~ ^[0-9]{1,3}$ && "${color[0]}" -ge 0 && "${color[0]}" -le 255 &&
          "${color[1]}" =~ ^[0-9]{1,3}$ && "${color[1]}" -ge 0 && "${color[1]}" -le 255 &&
          "${color[2]}" =~ ^[0-9]{1,3}$ && "${color[2]}" -ge 0 && "${color[2]}" -le 255 ]]; then
        local r=${color[0]}
        local g=${color[1]}
        local b=${color[2]}

        echo -E "\e[${layer};2;${r};${g};${b}m"
    elif [[ $color_len -eq 1 && "${color[0]}" =~ ^[0-9A-Fa-f]{6}$ ]]; then
        local hex="${color[0]}"

        local r=$(( 16#${hex:0:2} ))
        local g=$(( 16#${hex:2:2} ))
        local b=$(( 16#${hex:4:2} ))
        
        echo -E "\e[${layer};2;${r};${g};${b}m"
    elif [[ $color_len -eq 1 && "${color[0]}" =~ ^[0-9]{1,3}$ && "${color[0]}" -ge 0 && "${color[0]}" -le 255 ]]; then
        local ansi=${color[0]}

        echo -E "\e[${layer};5;${ansi}m"
    else
        return 1
    fi

    return 0
}

usage() {
    echo -e "\
$appname v$version - Script for customizing text appearance.

Usage: $appname [options] [arguments]

Options:
  -fore <COLOR>
    Set foreground color using available color palettes.

  -back <COLOR>
    Set background color using available color palettes.

  -style <STYLES>
    Set style(s) to text using available styles.

  -mark <MARKER>
    Set status marker to string using available markers.

  -reset
    Reset all formatting to default appearance.

  -help
    Output this help message.

Available color palettes:
  RGB format: <$(get_color "255 0 0" "fore")R\e[0m> <$(get_color "0 255 0" "fore")G\e[0m> <$(get_color "0 0 255" "fore")B\e[0m>, Example: $(get_color "160 0 255" "fore")160 0 255\e[0m
  HEX format: <$(get_color "00C8FF" "fore")HEX\e[0m>, Example: $(get_color "00C8FF" "fore")00C8FF\e[0m
  ANSI format: <$(get_color "215" "fore")ANSI\e[0m>, Example: $(get_color "215" "fore")215\e[0m

Available styles:
  ${text_styles[bold]}bold\e[0m | ${text_styles[italic]}italic\e[0m | ${text_styles[underline]}underline\e[0m | ${text_styles[flashing]}flashing\e[0m | ${text_styles[inverted]}inverted\e[0m

Available markers:
  success: ${status_markers[success]}  info: ${status_markers[info]}   question: ${status_markers[question]}   on: ${status_markers[on]}
  warning: ${status_markers[warning]}  error: ${status_markers[error]}  debug: ${status_markers[debug]}  off: ${status_markers[off]}\
"

    exit 0
}

if [ $# -eq 0 ]; then
    usage
fi

while [ $# -gt 0 ]; do
    case "$1" in
        "-fore" | "-back")
            args=($(get_args "$*"))
            args_len=${#args[@]}

            layer="${args[0]:1}"
            color="${args[*]:1}"

            result_color=$(get_color "$color" "$layer")

            if [ -n "$result_color" ]; then
                output+="$result_color"
            fi

            shift $args_len
            ;;
        "-style")
            args=($(get_args "$*"))
            args_len=${#args[@]}

            styles="${args[@]:1}"

            for style in $styles; do
                result_style="${text_styles[$(lowercase $style)]}"

                if [ -n "$result_style" ]; then
                    output+="$result_style"
                fi
            done

            shift $args_len
            ;;
        "-mark")
            args=($(get_args "$*"))
            args_len=${#args[@]}

            marker="${args[1]}"

            if [ -n "$marker" ]; then
                result_marker="${status_markers[$(lowercase $marker)]}"
            fi

            if [ -n "$result_marker" ]; then
                output="\e[0m $result_marker $output"
            fi

            shift $args_len
            ;;
        "-reset")
            output="\e[0m"
            break
            ;;
        "-help")
            usage
            ;;
        *)
            shift
            ;;
    esac
done

if [ -n "$output" ]; then
    echo -E "$output"
    exit 0
else
    exit 1
fi
